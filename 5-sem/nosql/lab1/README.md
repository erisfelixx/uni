# Варіант №15: Система управління ресторанним бізнесом
---
## 1. Види NoSQL баз даних
Основні типи NoSQL баз даних, якими я ознайомилася для загального розуміння та ознайомлення з альтернативами реляційним системам.

**1. Документо-орієнтовані (Document-oriented)**
- **Приклади:** MongoDB, CouchDB.
- **Суть:** Зберігають дані у вигляді JSON-подібних документів. Структура даних гнучка (schema-less), що дозволяє зберігати вкладені масиви та об'єкти.
- **Вердикт:** Ідеально підходять для нашої предметної області (зберігання складних чеків, історії замовлень), тому ми обрали **MongoDB** для архівування.

**2. Ключ-значення (Key-Value)**

- **Приклади:** Redis, DynamoDB, Memcached.
- **Суть:** Найпростіша модель, що працює як великий словник (хеш-мапа). Забезпечує найвищу швидкість доступу, але має обмежені можливості пошуку (тільки за ключем).
- **Вердикт:** Чудово підходять для кешування, сесій користувачів та кошика покупок. Ми використали **Redis** для реалізації тимчасового кошика.

**3. Колоночні (Column-family)**

- **Приклади:** Cassandra, HBase.
- **Суть:** Зберігають дані не рядками, а колонками. Оптимізовані для запису величезних обсягів даних (терабайти логів, телеметрія датчиків, часові ряди).
- **Чому не підходять:** Система ресторану не генерує такого потоку даних, щоб виправдати складність підтримки кластера Cassandra. Для нас це надлишково.

**4. Графові (Graph)**
- **Приклади:** Neo4j, Amazon Neptune.
- **Суть:** Оптимізовані для зберігання та швидкого обходу складних зв'язків між об'єктами (вузлами).
- **Чому не підходять:** У ресторанному бізнесі зв'язки прості та ієрархічні (Замовлення -> Страви). У нас немає складних мережевих структур, як у соціальних мережах ("друзі друзів") або рекомендаційних системах, де графи незамінні.

---

## 2. Враховуючи предметну область "Управління рестораном", чи буде ефективніше винести частину даних в іншу базу?

Використання **гібридного підходу (Polyglot Persistence)** є значно ефективнішим, ніж спроба вирішити всі задачі однією реляційною базою даних.

Для нашої системи доцільно залишити операційні дані (меню, бронювання, поточні замовлення) у **PostgreSQL**, а історію завершених замовлень (архів) та аналітичні дані винести у документо-орієнтовану базу, наприклад, MongoDB.

**1. Проблема "Важких JOIN-ів" та агрегації даних**

У реляційній моделі, чек - це не один об'єкт, а набір розрізнених рядків у різних таблицях (`Orders`, `Order_Items`, `Menu_Items`, `Payments`), які потрібно збирати докупи через операції `JOIN`.

 - *Ситуація*: Коли ми хочемо проаналізувати продажі за місяць або просто показати користувачу його історію за рік, базі доводиться виконувати тисячі операцій з'єднання таблиць.

 - *Перевага NoSQL*: У MongoDB ми зберігаємо замовлення як **єдиний агрегований документ (JSON)**. Отримання чека — це миттєва операція читання одного запису $O(1)$, без навантаження на процесор для обчислення зв'язків.


**2. Проблема Історичності даних (Snapshotting)**
Меню ресторану — це живий організм. Ціни змінюються, склад страв оновлюється, позиції видаляються.

 - *Ситуація в SQL*: Щоб зберегти історію (що клієнт купив борщ саме за 100 грн, а не за 120 грн, скільки він коштує зараз), нам доводиться дублювати дані (ціну, назву) в таблицю `Order_Items` або створювати складні механізми версійності меню.

 - *Перевага NoSQL*: Документний підхід природно підтримує патерн **Snapshotting**. Коли замовлення потрапляє в архів MongoDB, воно зберігається як "знімок часу". Якщо ми змінимо меню в PostgreSQL, це ніяк не вплине на цілісність історичних документів у MongoDB.


**3. Гнучкість структури (Semi-structured Data)**
Замовлення в ресторані часто мають нестандартні атрибути: "без солі", "подвійний сир", "подати через 10 хв", "алергія на горіхи".

 - *Ситуація в SQL*: Додавання таких нюансів вимагає створення додаткових таблиць (`Order_Item_Modifiers`) або використання EAV-патернів, що ускладнює запити.

 - *Перевага NoSQL*: Ми можемо легко додавати будь-які поля (нотатки, масиви модифікаторів) у документ конкретного замовлення без зміни схеми всієї бази даних.

---

## 3-4. Реалізація гібридної архітектури
Операційні дані, що вимагають суворої узгодженості (столи, активні замовлення), залишилися в **PostgreSQL**, тоді як історію закритих чеків було винесено в документо-орієнтовану базу **MongoDB**. 

Це рішення обґрунтоване природою архівних даних: чек є незмінним документом, який часто потрібно читати цілком для аналітики. У реляційній моделі це вимагає ресурсномістких операцій `JOIN` між трьома таблицями, тоді як у NoSQL ми зберігаємо чек як єдиний **агрегований JSON-документ** **(патерн Embedding)**. 

Крім того, документний підхід автоматично вирішує проблему версійності цін (**Snapshotting**): назви та вартість страв фіксуються в документі на момент замовлення, що дозволяє змінювати поточне меню без впливу на історичні звіти.


Також було реалізовано аналогічний механізм створення замовлення в реляційній базі (метод `create_order` у файлі `order_repository.py`).

---

## 5. Тестування та порівняння результатів

Ефективність обраного підходу була підтверджена практичним тестуванням за допомогою скрипта `benchmark.py`, який емулював масове створення 1000 замовлень в обох базах. Результати показали, що запис у MongoDB відбувається значно швидше (у 1.5–2 рази).

```
--- SQL Benchmark: Creating 1000 orders ---
SQL Time: 0.5815 seconds

--- MongoDB Benchmark: Inserting 1000 documents ---
MongoDB Time: 0.3256 seconds

==============================
RESULTS:
SQL Average: 0.00058 sec/op
Mongo Average: 0.00033 sec/op

MongoDB was 1.79x times faster than PostgreSQL
```

- **MongoDB** виконує збереження всього замовлення як одну атомарну операцію запису документа.
- **PostgreSQL** змушена виконувати серію з $N+1$ запитів, перевіряти зовнішні ключі (Foreign Keys) та оновлювати індекси для кількох таблиць одночасно.

---

##  6. NoSql базу іншого типу

Для виконання цього пункту було обрано базу даних типу *Key-Value (Ключ-Значення)* — **Redis**.

У системі управління рестораном існує клас даних, які є тимчасовими, але вимагають надзвичайно швидкого доступу на запис та читання. Типовим прикладом є **"Кошик замовлень" (Shopping Cart)** на веб-сайті або в мобільному додатку.

 - Redis зберігає дані в оперативній пам'яті (In-Memory), що забезпечує мілісекундний відгук. Також він підтримує **TTL (Time To Live)**, що дозволяє кошику автоматично очищатися, якщо користувач покинув сайт, не займаючи місце вічно.

**Реалізація:** Було розроблено модуль `redis_demo.py`, який емулює роботу кошика. Для зручності тестування використано бібліотеку **fakeredis** (емуляція Redis у пам'яті Python), яка повністю відтворює API реального сервера.

**Базові запити (Redis Commands):**

**1. Збереження даних (Hashes)**: Ми використали структуру Hash, де ключем є ID сесії користувача, а полями — ID товарів.

- Redis команда: `HSET key field value`
- Python реалізація: `r.hset(f"cart:{session_id}", item_id, json_data)`
- Суть: Додає товар у кошик або оновлює його дані.

**2. Читання даних:**

- Redis команда: `HGETALL key`
- Python реалізація: `r.hgetall(f"cart:{session_id}")`
- Суть: Отримує повний вміст кошика (всі товари та їх кількість) за один запит.

**3. Керування часом життя (TTL):**

- Redis команда: `EXPIRE key seconds`
- Python реалізація: `r.expire(f"cart:{session_id}", 3600)`
- Суть: Встановлює таймер на 1 годину. Якщо користувач не активний, кошик видаляється автоматично.

**4. Видалення:**

- Redis команда: `DEL key`
- Python реалізація: `r.delete(f"cart:{session_id}")`
- Суть: Повне очищення кошика після оформлення замовлення.
















